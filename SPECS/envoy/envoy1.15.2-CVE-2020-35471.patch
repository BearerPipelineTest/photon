commit 1ed6ddfb615307755643f810b078ca7fe9d771fa
Author: Christoph Pakulski <christoph@tetrate.io>
Date:   Fri Nov 20 17:00:27 2020 -0500

    udp: properly handle truncated/dropped datagrams (#14122)
    
    Signed-off-by: Matt Klein <mklein@lyft.com>
    Signed-off-by: Christoph Pakulski <christoph@tetrate.io>
    Co-authored-by: Matt Klein <mklein@lyft.com>
    Co-authored-by: Christoph Pakulski <christoph@tetrate.io>
Re-created patch for version 1.15.2
diff --git a/include/envoy/network/io_handle.h b/include/envoy/network/io_handle.h
index 1329122..5255ba4 100644
--- a/include/envoy/network/io_handle.h
+++ b/include/envoy/network/io_handle.h
@@ -89,6 +89,10 @@ public:
     Address::InstanceConstSharedPtr peer_address_;
     // The payload length of this packet.
     unsigned int msg_len_{0};
+    // If true indicates a successful syscall, but the packet was dropped due to truncation. We do
+    //  not support receiving truncated packets.
+    bool truncated_and_dropped_{false};
+
   };
 
   /**
diff --git a/source/common/api/win32/os_sys_calls_impl.cc b/source/common/api/win32/os_sys_calls_impl.cc
index fa8af1a..da38dad 100644
--- a/source/common/api/win32/os_sys_calls_impl.cc
+++ b/source/common/api/win32/os_sys_calls_impl.cc
@@ -145,14 +145,22 @@ SysCallSizeResult OsSysCallsImpl::recv(os_fd_t socket, void* buffer, size_t leng
 }
 
 SysCallSizeResult OsSysCallsImpl::recvmsg(os_fd_t sockfd, msghdr* msg, int flags) {
-  DWORD bytes_received;
+  DWORD bytes_received = 0;
   LPFN_WSARECVMSG recvmsg_fn_ptr = getFnPtrWSARecvMsg();
   WSAMSGPtr wsa_msg = msghdrToWSAMSG(msg);
   // Windows supports only a single flag on input to WSARecvMsg
   wsa_msg->dwFlags = flags & MSG_PEEK;
   const int rc = recvmsg_fn_ptr(sockfd, wsa_msg.get(), &bytes_received, nullptr, nullptr);
   if (rc == SOCKET_ERROR) {
-    return {-1, ::WSAGetLastError()};
+	// We try to match the UNIX behavior for truncated packages. In that case the return code is
+	// the length of the allocated buffer and we get the value from `dwFlags`.
+	auto last_error = ::WSAGetLastError();
+	if (last_error == WSAEMSGSIZE) {
+		msg->msg_flags = wsamsg.wsamsg_->dwFlags;
+		return {bytes_received, 0};
+	}
+
+	return {rc, last_error};
   }
   msg->msg_namelen = wsa_msg->namelen;
   msg->msg_flags = wsa_msg->dwFlags;
diff --git a/source/common/network/io_socket_handle_impl.cc b/source/common/network/io_socket_handle_impl.cc
index 306c0c4..f16a37c 100644
--- a/source/common/network/io_socket_handle_impl.cc
+++ b/source/common/network/io_socket_handle_impl.cc
@@ -12,6 +12,15 @@ using Envoy::Api::SysCallIntResult;
 using Envoy::Api::SysCallSizeResult;
 
 namespace Envoy {
+	constexpr int messageTruncatedOption() {
+		#if defined(__APPLE__)
+		// OSX does not support passing `MSG_TRUNC` to recvmsg and recvmmsg. This does not effect
+		// functionality and it primarily used for logging.
+			return 0;
+		#else
+			return MSG_TRUNC;
+		#endif
+	}
 namespace Network {
 
 IoSocketHandleImpl::~IoSocketHandleImpl() {
@@ -234,10 +243,17 @@ Api::IoCallUint64Result IoSocketHandleImpl::recvmsg(Buffer::RawSlice* slices,
   hdr.msg_flags = 0;
   hdr.msg_control = cbuf.begin();
   hdr.msg_controllen = cmsg_space_;
-  const Api::SysCallSizeResult result = Api::OsSysCallsSingleton::get().recvmsg(fd_, &hdr, 0);
+  Api::SysCallSizeResult result = Api::OsSysCallsSingleton::get().recvmsg(fd_, &hdr, messageTruncatedOption());
   if (result.rc_ < 0) {
     return sysCallResultToIoCallResult(result);
   }
+   if ((hdr.msg_flags & MSG_TRUNC) != 0) {
+    ENVOY_LOG_MISC(debug, "Dropping truncated UDP packet with size: {}.", result.rc_);
+    result.rc_ = 0;
+    (*output.dropped_packets_)++;
+    output.msg_[0].truncated_and_dropped_ = true;
+    return sysCallResultToIoCallResult(result);
+  }
 
   RELEASE_ASSERT((hdr.msg_flags & MSG_CTRUNC) == 0,
                  fmt::format("Incorrectly set control message length: {}", hdr.msg_controllen));
@@ -260,7 +276,8 @@ Api::IoCallUint64Result IoSocketHandleImpl::recvmsg(Buffer::RawSlice* slices,
       if (output.dropped_packets_ != nullptr) {
         absl::optional<uint32_t> maybe_dropped = maybeGetPacketsDroppedFromHeader(*cmsg);
         if (maybe_dropped) {
-          *output.dropped_packets_ = *maybe_dropped;
+          *output.dropped_packets_ += *maybe_dropped;
+	  continue;
         }
       }
     }
@@ -306,8 +323,8 @@ Api::IoCallUint64Result IoSocketHandleImpl::recvmmsg(RawSliceArrays& slices, uin
   // Set MSG_WAITFORONE so that recvmmsg will not waiting for
   // |num_packets_per_mmsg_call| packets to arrive before returning when the
   // socket is a blocking socket.
-  const Api::SysCallIntResult result = Api::OsSysCallsSingleton::get().recvmmsg(
-      fd_, mmsg_hdr.data(), num_packets_per_mmsg_call, MSG_TRUNC | MSG_WAITFORONE, nullptr);
+  Api::SysCallIntResult result = Api::OsSysCallsSingleton::get().recvmmsg(
+      fd_, mmsg_hdr.data(), num_packets_per_mmsg_call, messageTruncatedOption() | MSG_TRUNC | MSG_WAITFORONE, nullptr);
 
   if (result.rc_ <= 0) {
     return sysCallResultToIoCallResult(result);
@@ -316,18 +333,18 @@ Api::IoCallUint64Result IoSocketHandleImpl::recvmmsg(RawSliceArrays& slices, uin
   int num_packets_read = result.rc_;
 
   for (int i = 0; i < num_packets_read; ++i) {
-    if (mmsg_hdr[i].msg_len == 0) {
+    msghdr& hdr = mmsg_hdr[i].msg_hdr;
+    if ((hdr.msg_flags & MSG_TRUNC) != 0) {
+      ENVOY_LOG_MISC(debug, "Dropping truncated UDP packet with size: {}.", mmsg_hdr[i].msg_len);
+      (*output.dropped_packets_)++;
+      output.msg_[i].truncated_and_dropped_ = true;
+
       continue;
     }
-    msghdr& hdr = mmsg_hdr[i].msg_hdr;
     RELEASE_ASSERT((hdr.msg_flags & MSG_CTRUNC) == 0,
                    fmt::format("Incorrectly set control message length: {}", hdr.msg_controllen));
     RELEASE_ASSERT(hdr.msg_namelen > 0,
                    fmt::format("Unable to get remote address from recvmmsg() for fd: {}", fd_));
-    if ((hdr.msg_flags & MSG_TRUNC) != 0) {
-      ENVOY_LOG_MISC(warn, "Dropping truncated UDP packet with size: {}.", mmsg_hdr[i].msg_len);
-      continue;
-    }
 
     output.msg_[i].msg_len_ = mmsg_hdr[i].msg_len;
     // Get local and peer addresses for each packet.
@@ -353,7 +370,7 @@ Api::IoCallUint64Result IoSocketHandleImpl::recvmmsg(RawSliceArrays& slices, uin
       for (cmsg = CMSG_FIRSTHDR(&hdr); cmsg != nullptr; cmsg = CMSG_NXTHDR(&hdr, cmsg)) {
         absl::optional<uint32_t> maybe_dropped = maybeGetPacketsDroppedFromHeader(*cmsg);
         if (maybe_dropped) {
-          *output.dropped_packets_ = *maybe_dropped;
+          *output.dropped_packets_ += *maybe_dropped;
         }
       }
     }
diff --git a/source/common/network/udp_listener_impl.h b/source/common/network/udp_listener_impl.h
index 2184b44..dae0c4f 100644
--- a/source/common/network/udp_listener_impl.h
+++ b/source/common/network/udp_listener_impl.h
@@ -26,6 +26,7 @@ public:
                   UdpListenerCallbacks& cb, TimeSource& time_source);
 
   ~UdpListenerImpl() override;
+  uint32_t packetsDropped() { return packets_dropped_; }
 
   // Network::Listener Interface
   void disable() override;
diff --git a/source/common/network/utility.cc b/source/common/network/utility.cc
index 891e6f9..2756a28 100644
--- a/source/common/network/utility.cc
+++ b/source/common/network/utility.cc
@@ -580,6 +580,9 @@ Api::IoCallUint64Result Utility::readFromSocket(IoHandle& handle,
     uint64_t packets_read = result.rc_;
     ENVOY_LOG_MISC(trace, "recvmmsg read {} packets", packets_read);
     for (uint64_t i = 0; i < packets_read; ++i) {
+      if (output.msg_[i].truncated_and_dropped_) {
+  	continue;
+      }
       Buffer::RawSlice* slice = slices[i].data();
       const uint64_t msg_len = output.msg_[i].msg_len_;
       ASSERT(msg_len <= slice->len_);
@@ -601,7 +604,9 @@ Api::IoCallUint64Result Utility::readFromSocket(IoHandle& handle,
       handle.recvmsg(&slice, num_slices, local_address.ip()->port(), output);
 
   if (!result.ok()) {
-    return result;
+    if (!result.ok() || output.msg_[0].truncated_and_dropped_) {
+        return result;
+    }
   }
 
   ENVOY_LOG_MISC(trace, "recvmsg bytes {}", result.rc_);
@@ -627,11 +632,6 @@ Api::IoErrorPtr Utility::readPacketsFromSocket(IoHandle& handle,
       return std::move(result.err_);
     }
 
-    if (result.rc_ == 0) {
-      // TODO(conqerAtapple): Is zero length packet interesting? If so add stats
-      // for it. Otherwise remove the warning log below.
-      ENVOY_LOG_MISC(trace, "received 0-length packet");
-    }
 
     if (packets_dropped != old_packets_dropped) {
       // The kernel tracks SO_RXQ_OVFL as a uint32 which can overflow to a smaller
