From 7e190b0798183c4f84cd7df8a7b275a1a450b734 Mon Sep 17 00:00:00 2001
From: Kevin Wang <wxianzhao@vmware.com>
Date: Wed, 2 Feb 2022 18:36:31 +0000
Subject: [PATCH] iproute2: Add HCX patches to iproute2

These patches add support for mss-clamping, ip trunk command
and sink_connected option for slave bridge devices

[ Sharan: Forward ported these patches for v4.18.0. Have listed out
  the changes below -

  1) In print_xplicit_linkinfo in ip/ipaddress.c, get rid of
     SPRINT_BUF(bmaster) since ll_idx_n2a() does not need it anymore

  2) Use the if_link.h, if_tunnel.h, rtnetlink.h from linux-secure-devel
     rpms. In all the header files, remove __UAPI from #defines since that's
     used only in the kernel.

  3) In vxlan_trunk_parse_opt() in ip/link_vxlan_trunk.c and iptrunk_op() in
     ip/iptrunk.c, add a #define for the magic number used for buf[] size in
     struct req.

  4) In vxlan_trunk_parse_opt() in ip/link_vxlan_trunk.c, rtnl_talk() dynamically
     allocates buffer from the heap in v4.18.0 while invoking rtnl_recvmsg() for
     capturing responses. Due to the dynamic allocation, we will need to ensure
     answer is freed whenever necessary.
     We parse the responses from answer instead of req.

  5) The original patchset added #define RTNL_FAMILY_TRUNK to ip/iptrunk.c. This is already
     defined in include/uapi/linux/rtnetlink.h, therefore remove it from iptrunk.c ]

Signed-off-by: Sharan Turlapati <sturlapati@vmware.com>
---
 bridge/bridge.c                |   4 +
 bridge/fdb.c                   |  43 +++++
 bridge/link.c                  |  16 +-
 include/uapi/linux/if_link.h   |  18 ++
 include/uapi/linux/if_tunnel.h |   2 +
 include/uapi/linux/rtnetlink.h |  10 +-
 include/utils.h                |   1 +
 ip/Makefile                    |   1 +
 ip/ip.c                        |   7 +-
 ip/ip_common.h                 |   1 +
 ip/ipaddress.c                 |  29 +++
 ip/iplink_bridge_slave.c       |  11 +-
 ip/iptrunk.c                   | 315 +++++++++++++++++++++++++++++++++
 ip/link_gre.c                  |  63 ++++---
 ip/link_vxlan_trunk.c          | 164 +++++++++++++++++
 15 files changed, 660 insertions(+), 25 deletions(-)
 create mode 100644 ip/iptrunk.c
 create mode 100644 ip/link_vxlan_trunk.c

diff --git a/bridge/bridge.c b/bridge/bridge.c
index 7fcfe111..cabd83fc 100644
--- a/bridge/bridge.c
+++ b/bridge/bridge.c
@@ -28,6 +28,7 @@ int color;
 int compress_vlans;
 int json;
 int timestamp;
+int explicit_output;
 char *batch_file;
 int force;
 const char *_SL_;
@@ -42,6 +43,7 @@ static void usage(void)
 "where	OBJECT := { link | fdb | mdb | vlan | monitor }\n"
 "	OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] |\n"
 "		     -o[neline] | -t[imestamp] | -n[etns] name |\n"
+"		     -x[plicit] |\n"
 "		     -c[ompressvlans] -color -p[retty] -j{son} }\n");
 	exit(-1);
 }
@@ -189,6 +191,8 @@ main(int argc, char **argv)
 			if (argc <= 1)
 				usage();
 			batch_file = argv[1];
+		} else if (matches(opt, "-xplicit") == 0) {
+			++explicit_output;
 		} else {
 			fprintf(stderr,
 				"Option \"%s\" is unknown, try \"bridge help\".\n",
diff --git a/bridge/fdb.c b/bridge/fdb.c
index 4dbc894c..19ed3463 100644
--- a/bridge/fdb.c
+++ b/bridge/fdb.c
@@ -123,6 +123,41 @@ static void fdb_print_stats(FILE *fp, const struct nda_cacheinfo *ci)
 	}
 }
 
+static void print_fdb_explicit(struct rtattr * tb[NDA_MAX+1],
+			       struct ndmsg *r,
+			       FILE *fp)
+{
+	SPRINT_BUF(blladdr);
+	char bdev[IFNAMSIZ+1] = "<unknown>";
+	char *lladdr = "<unknown>";
+	char vlan[20] = "";
+	char masterdev[IFNAMSIZ+1] = "";
+
+	if (tb[NDA_LLADDR]) {
+		ll_addr_n2a(RTA_DATA(tb[NDA_LLADDR]),
+			    RTA_PAYLOAD(tb[NDA_LLADDR]),
+			    ll_index_to_type(r->ndm_ifindex),
+			    blladdr, sizeof(blladdr));
+		lladdr = blladdr;
+	}
+	if (!filter_index && r->ndm_ifindex) {
+		strncpy(bdev, ll_index_to_name(r->ndm_ifindex), sizeof(bdev)-1);
+		bdev[sizeof(bdev)-1] = 0;
+	}
+	if (tb[NDA_VLAN]) {
+		__u16 vid = rta_getattr_u16(tb[NDA_VLAN]);
+		snprintf(vlan, sizeof(vlan), "%hu", vid);
+	}
+	if (tb[NDA_MASTER]) {
+		strncpy(masterdev, ll_index_to_name(rta_getattr_u32(tb[NDA_MASTER])),
+			sizeof(masterdev)-1);
+		masterdev[sizeof(masterdev)-1] = 0;
+	}
+	fprintf(fp, "%s|%s|%s|%s|%s",
+		lladdr, bdev, vlan, masterdev,
+		state_n2a(r->ndm_state));
+}
+
 int print_fdb(const struct sockaddr_nl *who, struct nlmsghdr *n, void *arg)
 {
 	FILE *fp = arg;
@@ -162,6 +197,14 @@ int print_fdb(const struct sockaddr_nl *who, struct nlmsghdr *n, void *arg)
 		return 0;
 
 	open_json_object(NULL);
+
+	if (explicit_output) {
+		print_fdb_explicit(tb, r, fp);
+		fprintf(fp, "\n");
+		fflush(fp);
+		return 0;
+	}
+
 	if (n->nlmsg_type == RTM_DELNEIGH)
 		print_bool(PRINT_ANY, "deleted", "Deleted ", true);
 
diff --git a/bridge/link.c b/bridge/link.c
index 8d89aca2..801eb1c7 100644
--- a/bridge/link.c
+++ b/bridge/link.c
@@ -152,6 +152,10 @@ static void print_protinfo(FILE *fp, struct rtattr *attr)
 		if (prtb[IFLA_BRPORT_VLAN_TUNNEL])
 			print_onoff(fp, "vlan_tunnel",
 				    rta_getattr_u8(prtb[IFLA_BRPORT_VLAN_TUNNEL]));
+		if (prtb[IFLA_BRPORT_SINK_CONNECTED])
+			print_onoff(fp, "sink_connected",
+				rta_getattr_u8(prtb[IFLA_BRPORT_SINK_CONNECTED]));
+
 	} else
 		print_portstate(rta_getattr_u8(attr));
 }
@@ -251,6 +255,7 @@ static void usage(void)
 	fprintf(stderr,	"                               [ neigh_suppress {on | off} ]\n");
 	fprintf(stderr,	"                               [ vlan_tunnel {on | off} ]\n");
 	fprintf(stderr, "                               [ hwmode {vepa | veb} ]\n");
+	fprintf(stderr, "                               [ sink_connected {on | off} ]\n");
 	fprintf(stderr, "                               [ self ] [ master ]\n");
 	fprintf(stderr, "       bridge link show [dev DEV]\n");
 	exit(-1);
@@ -298,6 +303,7 @@ static int brlink_modify(int argc, char **argv)
 	__u32 cost = 0;
 	__s16 priority = -1;
 	__s8 state = -1;
+	__s8 sink_connected = -1;
 	__s16 mode = -1;
 	__u16 flags = 0;
 	struct rtattr *nest;
@@ -386,7 +392,11 @@ static int brlink_modify(int argc, char **argv)
 			if (!on_off("vlan_tunnel", &vlan_tunnel,
 				    *argv))
 				return -1;
-		} else {
+		} else if (strcmp(*argv, "sink_connected") == 0) {
+			NEXT_ARG();
+			if (!on_off("sink_connected", &sink_connected, *argv))
+				return -1;
+                } else {
 			usage();
 		}
 		argc--; argv++;
@@ -464,6 +474,10 @@ static int brlink_modify(int argc, char **argv)
 		addattr_nest_end(&req.n, nest);
 	}
 
+	if (sink_connected >= 0)
+		addattr8(&req.n, sizeof(req), IFLA_BRPORT_SINK_CONNECTED,
+			 sink_connected);
+
 	if (rtnl_talk(&rth, &req.n, NULL) < 0)
 		return -1;
 
diff --git a/include/uapi/linux/if_link.h b/include/uapi/linux/if_link.h
index 4eccc7ff..2a7db4c0 100644
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@ -164,6 +164,8 @@ enum {
 	IFLA_CARRIER_UP_COUNT,
 	IFLA_CARRIER_DOWN_COUNT,
 	IFLA_NEW_IFINDEX,
+	IFLA_MIN_MTU,
+	IFLA_MAX_MTU,
 	__IFLA_MAX
 };
 
@@ -332,6 +334,8 @@ enum {
 	IFLA_BRPORT_GROUP_FWD_MASK,
 	IFLA_BRPORT_NEIGH_SUPPRESS,
 	IFLA_BRPORT_ISOLATED,
+	IFLA_BRPORT_BACKUP_PORT,
+	IFLA_BRPORT_SINK_CONNECTED,
 	__IFLA_BRPORT_MAX
 };
 #define IFLA_BRPORT_MAX (__IFLA_BRPORT_MAX - 1)
@@ -457,6 +461,16 @@ enum {
 
 #define IFLA_MACSEC_MAX (__IFLA_MACSEC_MAX - 1)
 
+/* XFRM section */
+enum {
+	IFLA_XFRM_UNSPEC,
+	IFLA_XFRM_LINK,
+	IFLA_XFRM_IF_ID,
+	__IFLA_XFRM_MAX
+};
+
+#define IFLA_XFRM_MAX (__IFLA_XFRM_MAX - 1)
+
 enum macsec_validation_type {
 	MACSEC_VALIDATE_DISABLED = 0,
 	MACSEC_VALIDATE_CHECK = 1,
@@ -918,6 +932,7 @@ enum {
 	XDP_ATTACHED_DRV,
 	XDP_ATTACHED_SKB,
 	XDP_ATTACHED_HW,
+	XDP_ATTACHED_MULTI,
 };
 
 enum {
@@ -926,6 +941,9 @@ enum {
 	IFLA_XDP_ATTACHED,
 	IFLA_XDP_FLAGS,
 	IFLA_XDP_PROG_ID,
+	IFLA_XDP_DRV_PROG_ID,
+	IFLA_XDP_SKB_PROG_ID,
+	IFLA_XDP_HW_PROG_ID,
 	__IFLA_XDP_MAX,
 };
 
diff --git a/include/uapi/linux/if_tunnel.h b/include/uapi/linux/if_tunnel.h
index ecdc7666..fef9edf7 100644
--- a/include/uapi/linux/if_tunnel.h
+++ b/include/uapi/linux/if_tunnel.h
@@ -53,6 +53,7 @@ struct ip_tunnel_parm {
 	__be32			i_key;
 	__be32			o_key;
 	struct iphdr		iph;
+	__u16           mss_clamp;
 };
 
 enum {
@@ -140,6 +141,7 @@ enum {
 	IFLA_GRE_ERSPAN_VER,
 	IFLA_GRE_ERSPAN_DIR,
 	IFLA_GRE_ERSPAN_HWID,
+	IFLA_GRE_MSS_CLAMP,
 	__IFLA_GRE_MAX,
 };
 
diff --git a/include/uapi/linux/rtnetlink.h b/include/uapi/linux/rtnetlink.h
index c3a7d8ec..76371d44 100644
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@ -13,7 +13,8 @@
  */
 #define RTNL_FAMILY_IPMR		128
 #define RTNL_FAMILY_IP6MR		129
-#define RTNL_FAMILY_MAX			129
+#define RTNL_FAMILY_TRUNK               130
+#define RTNL_FAMILY_MAX                 130
 
 /****
  *		Routing/neighbour discovery messages.
@@ -150,6 +151,13 @@ enum {
 	RTM_NEWCACHEREPORT = 96,
 #define RTM_NEWCACHEREPORT RTM_NEWCACHEREPORT
 
+	RTM_NEWCHAIN = 100,
+#define RTM_NEWCHAIN RTM_NEWCHAIN
+	RTM_DELCHAIN,
+#define RTM_DELCHAIN RTM_DELCHAIN
+	RTM_GETCHAIN,
+#define RTM_GETCHAIN RTM_GETCHAIN
+
 	__RTM_MAX,
 #define RTM_MAX		(((__RTM_MAX + 3) & ~3) - 1)
 };
diff --git a/include/utils.h b/include/utils.h
index 8cb4349e..50f5d70c 100644
--- a/include/utils.h
+++ b/include/utils.h
@@ -27,6 +27,7 @@ extern int json;
 extern int pretty;
 extern int timestamp;
 extern int timestamp_short;
+extern int explicit_output;
 extern const char * _SL_;
 extern int max_flush_loops;
 extern int batch_mode;
diff --git a/ip/Makefile b/ip/Makefile
index a88f9366..04c3fe5b 100644
--- a/ip/Makefile
+++ b/ip/Makefile
@@ -10,6 +10,7 @@ IPOBJ=ip.o ipaddress.o ipaddrlabel.o iproute.o iprule.o ipnetns.o \
     link_iptnl.o link_gre6.o iplink_bond.o iplink_bond_slave.o iplink_hsr.o \
     iplink_bridge.o iplink_bridge_slave.o ipfou.o iplink_ipvlan.o \
     iplink_geneve.o iplink_vrf.o iproute_lwtunnel.o ipmacsec.o ipila.o \
+    link_vxlan_trunk.o iptrunk.o \
     ipvrf.o iplink_xstats.o ipseg6.o iplink_netdevsim.o iplink_rmnet.o
 
 RTMONOBJ=rtmon.o
diff --git a/ip/ip.c b/ip/ip.c
index 71d5170c..140f262a 100644
--- a/ip/ip.c
+++ b/ip/ip.c
@@ -36,6 +36,7 @@ int timestamp;
 const char *_SL_;
 int force;
 int max_flush_loops = 10;
+int explicit_output = 0;
 int batch_mode;
 bool do_all;
 
@@ -50,7 +51,7 @@ static void usage(void)
 "       ip [ -force ] -batch filename\n"
 "where  OBJECT := { link | address | addrlabel | route | rule | neigh | ntable |\n"
 "                   tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm |\n"
-"                   netns | l2tp | fou | macsec | tcp_metrics | token | netconf | ila |\n"
+"                   netns | l2tp | fou | macsec | tcp_metrics | token | netconf | ila | trunk \n"
 "                   vrf | sr }\n"
 "       OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |\n"
 "                    -h[uman-readable] | -iec | -j[son] | -p[retty] |\n"
@@ -58,6 +59,7 @@ static void usage(void)
 "                    -4 | -6 | -I | -D | -B | -0 |\n"
 "                    -l[oops] { maximum-addr-flush-attempts } | -br[ief] |\n"
 "                    -o[neline] | -t[imestamp] | -ts[hort] | -b[atch] [filename] |\n"
+"                    -x[plicit] |\n"
 "                    -rc[vbuf] [size] | -n[etns] name | -a[ll] | -c[olor]}\n");
 	exit(-1);
 }
@@ -101,6 +103,7 @@ static const struct cmd {
 	{ "netconf",	do_ipnetconf },
 	{ "vrf",	do_ipvrf},
 	{ "sr",		do_seg6 },
+	{ "trunk",      do_iptrunk },
 	{ "help",	do_help },
 	{ 0 }
 };
@@ -293,6 +296,8 @@ int main(int argc, char **argv)
 				exit(-1);
 		} else if (matches(opt, "-all") == 0) {
 			do_all = true;
+		} else if (matches(opt, "-xplicit") == 0) {
+			++explicit_output;
 		} else {
 			fprintf(stderr,
 				"Option \"%s\" is unknown, try \"ip -help\".\n",
diff --git a/ip/ip_common.h b/ip/ip_common.h
index 4d3227cb..f4d2492f 100644
--- a/ip/ip_common.h
+++ b/ip/ip_common.h
@@ -86,6 +86,7 @@ extern int do_ipila(int argc, char **argv);
 int do_tcp_metrics(int argc, char **argv);
 int do_ipnetconf(int argc, char **argv);
 int do_iptoken(int argc, char **argv);
+int do_iptrunk(int argc, char **argv);
 int do_ipvrf(int argc, char **argv);
 void vrf_reset(void);
 int netns_identify_pid(const char *pidstr, char *name, int len);
diff --git a/ip/ipaddress.c b/ip/ipaddress.c
index b7b78f6e..894463da 100644
--- a/ip/ipaddress.c
+++ b/ip/ipaddress.c
@@ -808,6 +808,28 @@ static void print_link_event(FILE *f, __u32 event)
 	}
 }
 
+
+static void print_xplicit_linkinfo(struct rtattr *tb[IFLA_MAX+1],
+                                 struct ifinfomsg *ifi,
+                                 FILE *fp)
+{
+	struct rtattr *linkinfo[IFLA_INFO_MAX+1];
+	char *linktype = "<unknown>";
+
+	if (tb[IFLA_LINKINFO]) {
+		parse_rtattr_nested(linkinfo, IFLA_INFO_MAX, tb[IFLA_LINKINFO]);
+		if (linkinfo[IFLA_INFO_KIND]) {
+			linktype = RTA_DATA(linkinfo[IFLA_INFO_KIND]);
+		}
+	}
+
+	fprintf(fp, "%d|%s|%s|%s",
+		ifi->ifi_index,
+		tb[IFLA_IFNAME] ? rta_getattr_str(tb[IFLA_IFNAME]) : "<nil>",
+		linktype,
+		tb[IFLA_MASTER] ? ll_idx_n2a(*(int*)RTA_DATA(tb[IFLA_MASTER])) : "");
+}
+
 int print_linkinfo(const struct sockaddr_nl *who,
 		   struct nlmsghdr *n, void *arg)
 {
@@ -861,6 +883,13 @@ int print_linkinfo(const struct sockaddr_nl *who,
 	if (filter.slave_kind && match_link_kind(tb, filter.slave_kind, 1))
 		return -1;
 
+	if (explicit_output) {
+		print_xplicit_linkinfo(tb, ifi, fp);
+		fprintf(fp, "\n");
+		fflush(fp);
+		return 1;
+	}
+
 	if (n->nlmsg_type == RTM_DELLINK)
 		print_bool(PRINT_ANY, "deleted", "Deleted ", true);
 
diff --git a/ip/iplink_bridge_slave.c b/ip/iplink_bridge_slave.c
index 3fbfb878..beb57ca0 100644
--- a/ip/iplink_bridge_slave.c
+++ b/ip/iplink_bridge_slave.c
@@ -39,6 +39,7 @@ static void print_explain(FILE *f)
 		"                        [ mcast_flood {on | off} ]\n"
 		"                        [ group_fwd_mask MASK ]\n"
 		"                        [ neigh_suppress {on | off} ]\n"
+		"                        [ sink_connected {on | off} ]\n"
 		"                        [ vlan_tunnel {on | off} ]\n"
 	);
 }
@@ -274,6 +275,10 @@ static void bridge_slave_print_opt(struct link_util *lu, FILE *f,
 	if (tb[IFLA_BRPORT_VLAN_TUNNEL])
 		_print_onoff(f, "vlan_tunnel", "vlan_tunnel",
 			     rta_getattr_u8(tb[IFLA_BRPORT_VLAN_TUNNEL]));
+
+	if (tb[IFLA_BRPORT_SINK_CONNECTED])
+		_print_onoff(f, "sink_connected", "sink_connected",
+			    rta_getattr_u8(tb[IFLA_BRPORT_SINK_CONNECTED]));
 }
 
 static void bridge_slave_parse_on_off(char *arg_name, char *arg_val,
@@ -382,7 +387,11 @@ static int bridge_slave_parse_opt(struct link_util *lu, int argc, char **argv,
 		} else if (matches(*argv, "help") == 0) {
 			explain();
 			return -1;
-		} else {
+		} else if (matches(*argv, "sink_connected") == 0) {
+			NEXT_ARG();
+			bridge_slave_parse_on_off("sink_connected", *argv, n,
+						  IFLA_BRPORT_SINK_CONNECTED);
+                } else {
 			fprintf(stderr, "bridge_slave: unknown option \"%s\"?\n",
 				*argv);
 			explain();
diff --git a/ip/iptrunk.c b/ip/iptrunk.c
new file mode 100644
index 00000000..86411303
--- /dev/null
+++ b/ip/iptrunk.c
@@ -0,0 +1,315 @@
+/*
+ * iptrunk.c    "ip trunk"
+ *
+ *              This program is free software; you can redistribute it and/or
+ *              modify it under the terms of the GNU General Public License
+ *              as published by the Free Software Foundation; either version
+ *              2 of the License, or (at your option) any later version.
+ *
+ * Authors:     Daniel Borkmann, <borkmann@redhat.com>
+ *              VMware, Inc.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/ip.h>
+#include <arpa/inet.h>
+#include <linux/types.h>
+#include <linux/if.h>
+
+#include "rt_names.h"
+#include "utils.h"
+#include "ip_common.h"
+
+extern struct rtnl_handle rth;
+
+struct rtnl_dump_args {
+	FILE *fp;
+	int ifindex;
+};
+
+#define TRF_SRC_VLAN 0x01
+#define TRF_SRC_VNI  0x02
+#define TRF_DST_VLAN 0x04
+#define TRF_DST_VNI  0x08
+#define TRF_ENABLED  0x10
+
+#define TRF_SRC_MASK (TRF_SRC_VLAN | TRF_SRC_VNI)
+#define TRF_DST_MASK (TRF_DST_VLAN | TRF_DST_VNI)
+
+#define TRF_VNI_TO_VLAN (TRF_SRC_VNI | TRF_DST_VLAN)
+#define TRF_VLAN_TO_VLAN (TRF_SRC_VLAN | TRF_DST_VLAN)
+
+enum {
+	TRM_UNSPEC,
+	TRM_ADD,
+	TRM_DEL,
+	TRM_ENABLE,
+	TRM_DISABLE,
+	__TRM_MAX
+};
+
+#define TRM_MAX (__TRM_MAX - 1)
+
+struct trmsg {
+	__u8            trm_family;
+	__u8            trm_op;
+	__u8            trm_flags;
+	__u8            trm_pad1;
+	__s32           trm_ifindex;
+};
+
+enum {
+	TRA_UNSPEC,
+	TRA_SRC,
+	TRA_DST,
+	TRA_ENABLED,
+	/* read-only statistics */
+	TRA_RX_PCKTS,
+	TRA_TX_PCKTS,
+	TRA_RX_BYTES,
+	TRA_TX_BYTES,
+	TRA_RX_PCKTS_DISABLED,
+	TRA_TX_PCKTS_DISABLED,
+	TRA_RX_BYTES_DISABLED,
+	TRA_TX_BYTES_DISABLED,
+	__TRA_MAX
+};
+
+#define TRA_MAX (__TRA_MAX - 1)
+
+#define TRA_RTA(r) \
+       ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct trmsg))))
+
+static void usage(void) __attribute__((noreturn));
+
+static void usage(void)
+{
+	fprintf(stderr, "Usage: ip trunk [ add | del | enable | disable ] LINK src SRC dst DST\n");
+	exit(-1);
+}
+
+static int print_trunk(const struct sockaddr_nl *who, struct nlmsghdr *n, void *arg)
+{
+	struct rtnl_dump_args *args = arg;
+	FILE *fp = args->fp;
+	int ifindex = args->ifindex;
+	struct trmsg *trm = NLMSG_DATA(n);
+	int len = n->nlmsg_len;
+	struct rtattr *tb[TRA_MAX + 1];
+
+	if (n->nlmsg_type != RTM_NEWNEIGH)
+		return -1;
+
+	len -= NLMSG_LENGTH(sizeof(*trm));
+	if (len < 0)
+		return -1;
+
+	if (trm->trm_family != RTNL_FAMILY_TRUNK)
+		return -1;
+	if (trm->trm_ifindex == 0)
+		return -1;
+	if (ifindex > 0 && trm->trm_ifindex != ifindex)
+		return 0;
+
+	parse_rtattr(tb, TRA_MAX, TRA_RTA(trm), len);
+	if (!tb[TRA_SRC]) {
+		fprintf(stderr, "Src not found!\n");
+		return -1;
+	}
+
+	if (!tb[TRA_DST]) {
+		fprintf(stderr, "Dst not found!\n");
+		return -1;
+	}
+
+	fprintf(fp, "mapping %d -> %d %sabled ",
+	        rta_getattr_u32(tb[TRA_SRC]),
+	        rta_getattr_u32(tb[TRA_DST]),
+	        rta_getattr_u32(tb[TRA_ENABLED]) ? "en" : "dis");
+	fprintf(fp, "dev %s ", ll_index_to_name(trm->trm_ifindex));
+	fprintf(fp, "\n");
+	if (show_details) {
+		fprintf(fp, "\trx packets: %llu\trx bytes: %llu\n",
+		        rta_getattr_u64(tb[TRA_RX_PCKTS]),
+		        rta_getattr_u64(tb[TRA_RX_BYTES]));
+		fprintf(fp, "\ttx packets: %llu\ttx bytes: %llu\n",
+		        rta_getattr_u64(tb[TRA_TX_PCKTS]),
+		        rta_getattr_u64(tb[TRA_TX_BYTES]));
+		fprintf(fp, "\trx packets: %llu\trx bytes: %llu\t(disabled)\n",
+		        rta_getattr_u64(tb[TRA_RX_PCKTS_DISABLED]),
+		        rta_getattr_u64(tb[TRA_RX_BYTES_DISABLED]));
+		fprintf(fp, "\ttx packets: %llu\ttx bytes: %llu\t(disabled)\n",
+		        rta_getattr_u64(tb[TRA_TX_PCKTS_DISABLED]),
+		        rta_getattr_u64(tb[TRA_TX_BYTES_DISABLED]));
+	}
+	fflush(fp);
+
+	return 0;
+}
+
+static int iptrunk_list(int argc, char **argv)
+{
+	int af = RTNL_FAMILY_TRUNK;
+	struct rtnl_dump_args da;
+	const struct rtnl_dump_filter_arg a[2] = {
+		{ .filter = print_trunk, .arg1 = &da, },
+		{ .filter = NULL, .arg1 = NULL, },
+	};
+
+	memset(&da, 0, sizeof(da));
+	da.fp = stdout;
+
+	while (argc > 0) {
+		if (strcmp(*argv, "dev") == 0) {
+			NEXT_ARG();
+			if ((da.ifindex = ll_name_to_index(*argv)) == 0)
+				invarg("dev is invalid\n", *argv);
+			break;
+		}
+		argc--; argv++;
+	}
+
+	if (rtnl_wilddump_request(&rth, af, RTM_GETLINK) < 0) {
+		perror("Cannot send dump request");
+		return -1;
+	}
+
+	if (rtnl_dump_filter_l(&rth, a) < 0) {
+		fprintf(stderr, "Dump terminated\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+#define XMIT_MAX_LEN 512
+
+static int iptrunk_op(int argc, char **argv, int operation)
+{
+	struct {
+		struct nlmsghdr n;
+		struct trmsg trm;
+		char buf[XMIT_MAX_LEN];
+	} req;
+	bool have_dev = false;
+	bool have_src = false;
+	bool have_dst = false;
+	__u32 src_id = 0;
+	__u32 dst_id = 0;
+
+	memset(&req, 0, sizeof(req));
+
+	req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct trmsg));
+	req.n.nlmsg_flags = NLM_F_REQUEST;
+	/* XXX: fix RTM_ value */
+	req.n.nlmsg_type = RTM_NEWNEIGH;
+	req.trm.trm_family = RTNL_FAMILY_TRUNK;
+	req.trm.trm_op = operation;
+
+	while (argc > 0) {
+		if (strcmp(*argv, "dev") == 0) {
+			NEXT_ARG();
+			if (!have_dev) {
+				if ((req.trm.trm_ifindex =
+				     ll_name_to_index(*argv)) == 0)
+					invarg("dev is invalid\n", *argv);
+				have_dev = true;
+				fprintf(stderr, "dev: %d\n", req.trm.trm_ifindex);
+			}
+		} else if (!matches(*argv, "src")) {
+			unsigned uval;
+
+			NEXT_ARG();
+			if ((get_unsigned(&uval, *argv, 0) < 0) ||
+			    (uval >= (1<<24))) {
+				fprintf(stderr,
+					"Invalid value for \"src\": \"%s\"; it should be an unsigned integer <= 2^24-1\n", *argv);
+				exit(-1);
+			}
+
+			src_id = uval;
+			have_src = true;
+		} else if (!matches(*argv, "dst")) {
+			unsigned uval;
+
+			NEXT_ARG();
+			if ((get_unsigned(&uval, *argv, 0) < 0) ||
+			    (uval >= 4095)) {
+				fprintf(stderr,
+					"Invalid value for \"dst\": \"%s\"; it should be an unsigned integer <= 4095\n", *argv);
+				exit(-1);
+			}
+
+			dst_id = uval;
+			have_dst = true;
+		} else {
+			if (matches(*argv, "help") == 0)
+				usage();
+		}
+		argc--; argv++;
+	}
+
+	if (!have_src) {
+		fprintf(stderr, "Not enough information: src "
+			"is required.\n");
+		return -1;
+	}
+	if (!have_dst) {
+		fprintf(stderr, "Not enough information: dst "
+			"is required.\n");
+		return -1;
+	}
+	if (!have_dev) {
+		fprintf(stderr, "Not enough information: \"dev\" "
+			"argument is required.\n");
+		return -1;
+	}
+
+	/*
+	 * Technically, vni can be anything < 2^24.  But ESX/NSX mgmt
+	 * only allows > 5000, so if src < 4096, assume vlan, else vni.
+	 */
+	if (src_id < 4096) {
+		req.trm.trm_flags = TRF_VLAN_TO_VLAN;
+	} else {
+		req.trm.trm_flags = TRF_VNI_TO_VLAN;
+	}
+	addattr32(&req.n, XMIT_MAX_LEN, TRA_SRC, src_id);
+	addattr32(&req.n, XMIT_MAX_LEN, TRA_DST, dst_id);
+
+	if (rtnl_talk(&rth, &req.n, NULL) < 0)
+		return -2;
+
+	return 0;
+}
+
+int do_iptrunk(int argc, char **argv)
+{
+	ll_init_map(&rth);
+
+	if (argc < 1) {
+		return iptrunk_list(0, NULL);
+	} else if (matches(argv[0], "add") == 0) {
+		return iptrunk_op(argc - 1, argv + 1, TRM_ADD);
+	} else if (matches(argv[0], "del") == 0) {
+		return iptrunk_op(argc - 1, argv + 1, TRM_DEL);
+	} else if (matches(argv[0], "enable") == 0) {
+		return iptrunk_op(argc - 1, argv + 1, TRM_ENABLE);
+	} else if (matches(argv[0], "disable") == 0) {
+		return iptrunk_op(argc - 1, argv + 1, TRM_DISABLE);
+	} else if (matches(argv[0], "list") == 0) {
+		return iptrunk_list(argc - 1, argv + 1);
+	} else if (matches(argv[0], "help") == 0)
+		usage();
+
+	fprintf(stderr, "Command \"%s\" is unknown, try \"ip trunk help\".\n", *argv);
+	exit(-1);
+}
diff --git a/ip/link_gre.c b/ip/link_gre.c
index ede761b2..b26b7578 100644
--- a/ip/link_gre.c
+++ b/ip/link_gre.c
@@ -52,6 +52,7 @@ static void gre_print_help(struct link_util *lu, int argc, char **argv, FILE *f)
 		"                     [ erspan IDX ]\n"
 		"                     [ erspan_dir { ingress | egress } ]\n"
 		"                     [ erspan_hwid hwid ]\n"
+		"                     [ mss-clamp ]\n"
 		"\n"
 	);
 	fprintf(f,
@@ -63,6 +64,8 @@ static void gre_print_help(struct link_util *lu, int argc, char **argv, FILE *f)
 	);
 }
 
+#define MSGBUFSZ 2048
+
 static int gre_parse_opt(struct link_util *lu, int argc, char **argv,
 			 struct nlmsghdr *n)
 {
@@ -70,6 +73,7 @@ static int gre_parse_opt(struct link_util *lu, int argc, char **argv,
 	struct {
 		struct nlmsghdr n;
 		struct ifinfomsg i;
+		char buf[MSGBUFSZ];
 	} req = {
 		.n.nlmsg_len = NLMSG_LENGTH(sizeof(*ifi)),
 		.n.nlmsg_flags = NLM_F_REQUEST,
@@ -96,6 +100,7 @@ static int gre_parse_opt(struct link_util *lu, int argc, char **argv,
 	__u16 encapflags = 0;
 	__u16 encapsport = 0;
 	__u16 encapdport = 0;
+	__u16 mss_clamp = 0;
 	__u8 metadata = 0;
 	__u32 fwmark = 0;
 	__u32 erspan_idx = 0;
@@ -201,6 +206,9 @@ get_failed:
 		if (greinfo[IFLA_GRE_ERSPAN_HWID])
 			erspan_hwid = rta_getattr_u16(greinfo[IFLA_GRE_ERSPAN_HWID]);
 
+		if (greinfo[IFLA_GRE_MSS_CLAMP])
+			mss_clamp = rta_getattr_u16(greinfo[IFLA_GRE_MSS_CLAMP]);
+
 		free(answer);
 	}
 
@@ -363,7 +371,14 @@ get_failed:
 			NEXT_ARG();
 			if (get_u16(&erspan_hwid, *argv, 0))
 				invarg("invalid erspan hwid\n", *argv);
-		} else {
+		} else if (strcmp(*argv, "mss-clamp") == 0) {
+			NEXT_ARG();
+			if (get_u16(&mss_clamp, *argv, 0))
+				invarg("Invalid mss-clamp.", *argv);
+			/* some arbitrary lower bound */
+			if ((mss_clamp > 0) &&  (mss_clamp < 500))
+				invarg("Invalid mss-clamp.", *argv);
+                } else {
 			gre_print_help(lu, argc, argv, stderr);
 			return -1;
 		}
@@ -391,35 +406,36 @@ get_failed:
 		return 0;
 	}
 
-	addattr32(n, 1024, IFLA_GRE_IKEY, ikey);
-	addattr32(n, 1024, IFLA_GRE_OKEY, okey);
-	addattr_l(n, 1024, IFLA_GRE_IFLAGS, &iflags, 2);
-	addattr_l(n, 1024, IFLA_GRE_OFLAGS, &oflags, 2);
+	addattr32(n, MSGBUFSZ, IFLA_GRE_IKEY, ikey);
+	addattr32(n, MSGBUFSZ, IFLA_GRE_OKEY, okey);
+	addattr_l(n, MSGBUFSZ, IFLA_GRE_IFLAGS, &iflags, 2);
+	addattr_l(n, MSGBUFSZ, IFLA_GRE_OFLAGS, &oflags, 2);
 	if (is_addrtype_inet(&saddr))
-		addattr_l(n, 1024, IFLA_GRE_LOCAL, saddr.data, saddr.bytelen);
+		addattr_l(n, MSGBUFSZ, IFLA_GRE_LOCAL, saddr.data, saddr.bytelen);
 	if (is_addrtype_inet(&daddr))
-		addattr_l(n, 1024, IFLA_GRE_REMOTE, daddr.data, daddr.bytelen);
-	addattr_l(n, 1024, IFLA_GRE_PMTUDISC, &pmtudisc, 1);
+		addattr_l(n, MSGBUFSZ, IFLA_GRE_REMOTE, daddr.data, daddr.bytelen);
+	addattr_l(n, MSGBUFSZ, IFLA_GRE_PMTUDISC, &pmtudisc, 1);
 	if (ignore_df)
-		addattr8(n, 1024, IFLA_GRE_IGNORE_DF, ignore_df & 1);
-	addattr_l(n, 1024, IFLA_GRE_TOS, &tos, 1);
+		addattr8(n, MSGBUFSZ, IFLA_GRE_IGNORE_DF, ignore_df & 1);
+	addattr_l(n, MSGBUFSZ, IFLA_GRE_TOS, &tos, 1);
 	if (link)
-		addattr32(n, 1024, IFLA_GRE_LINK, link);
-	addattr_l(n, 1024, IFLA_GRE_TTL, &ttl, 1);
-	addattr32(n, 1024, IFLA_GRE_FWMARK, fwmark);
+		addattr32(n, MSGBUFSZ, IFLA_GRE_LINK, link);
+	addattr_l(n, MSGBUFSZ, IFLA_GRE_TTL, &ttl, 1);
+	addattr32(n, MSGBUFSZ, IFLA_GRE_FWMARK, fwmark);
 	if (erspan_ver) {
-		addattr8(n, 1024, IFLA_GRE_ERSPAN_VER, erspan_ver);
+		addattr8(n, MSGBUFSZ, IFLA_GRE_ERSPAN_VER, erspan_ver);
 		if (erspan_ver == 1 && erspan_idx != 0) {
-			addattr32(n, 1024, IFLA_GRE_ERSPAN_INDEX, erspan_idx);
+			addattr32(n, MSGBUFSZ, IFLA_GRE_ERSPAN_INDEX, erspan_idx);
 		} else if (erspan_ver == 2) {
-			addattr8(n, 1024, IFLA_GRE_ERSPAN_DIR, erspan_dir);
-			addattr16(n, 1024, IFLA_GRE_ERSPAN_HWID, erspan_hwid);
+			addattr8(n, MSGBUFSZ, IFLA_GRE_ERSPAN_DIR, erspan_dir);
+			addattr16(n, MSGBUFSZ, IFLA_GRE_ERSPAN_HWID, erspan_hwid);
 		}
 	}
-	addattr16(n, 1024, IFLA_GRE_ENCAP_TYPE, encaptype);
-	addattr16(n, 1024, IFLA_GRE_ENCAP_FLAGS, encapflags);
-	addattr16(n, 1024, IFLA_GRE_ENCAP_SPORT, htons(encapsport));
-	addattr16(n, 1024, IFLA_GRE_ENCAP_DPORT, htons(encapdport));
+	addattr16(n, MSGBUFSZ, IFLA_GRE_ENCAP_TYPE, encaptype);
+	addattr16(n, MSGBUFSZ, IFLA_GRE_ENCAP_FLAGS, encapflags);
+	addattr16(n, MSGBUFSZ, IFLA_GRE_ENCAP_SPORT, htons(encapsport));
+	addattr16(n, MSGBUFSZ, IFLA_GRE_ENCAP_DPORT, htons(encapdport));
+	addattr16(n, MSGBUFSZ, IFLA_GRE_MSS_CLAMP, mss_clamp);
 
 	return 0;
 }
@@ -544,6 +560,11 @@ static void gre_print_opt(struct link_util *lu, FILE *f, struct rtattr *tb[])
 			    "erspan_hwid", "erspan_hwid 0x%x ", erspan_hwid);
 	}
 
+	if (tb[IFLA_GRE_MSS_CLAMP]) {
+		__u16 mss_clamp = rta_getattr_u16(tb[IFLA_GRE_MSS_CLAMP]);
+		print_0xhex(PRINT_ANY, "mss-clamp", "mss-clamp 0x%x ", mss_clamp);
+	}
+
 	tnl_print_encap(tb,
 			IFLA_GRE_ENCAP_TYPE,
 			IFLA_GRE_ENCAP_FLAGS,
diff --git a/ip/link_vxlan_trunk.c b/ip/link_vxlan_trunk.c
new file mode 100644
index 00000000..1271f6d4
--- /dev/null
+++ b/ip/link_vxlan_trunk.c
@@ -0,0 +1,164 @@
+/*
+ * link_vxlan_trunk.c  vxlan_trunk driver module
+ *
+ *             This program is free software; you can redistribute it and/or
+ *             modify it under the terms of the GNU General Public License
+ *             as published by the Free Software Foundation; either version
+ *             2 of the License, or (at your option) any later version.
+ *
+ * Authors:    Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ */
+
+#include <string.h>
+#include <net/if.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include <linux/ip.h>
+#include <linux/if_tunnel.h>
+#include "rt_names.h"
+#include "utils.h"
+#include "ip_common.h"
+#include "tunnel.h"
+
+static void print_usage(FILE *f)
+{
+	fprintf(f, "Usage: ip link { add | set | change | replace | del } NAME\n");
+	fprintf(f, "          type { vxlantrunk }\n");
+	fprintf(f, "\n");
+	fprintf(f, "Where: NAME := STRING\n");
+}
+
+static void usage(void) __attribute__((noreturn));
+static void usage(void)
+{
+	print_usage(stderr);
+	exit(-1);
+}
+
+enum blarg {
+	IFLA_VXLAN_TRUNK_UNSPEC,
+	IFLA_VXLAN_TRUNK_LINK,
+	IFLA_VXLAN_TRUNK_MAX = IFLA_VXLAN_TRUNK_LINK,
+};
+
+#define XMIT_MAX_LEN 2048
+
+static int vxlan_trunk_parse_opt(struct link_util *lu, int argc, char **argv,
+                                 struct nlmsghdr *n)
+{
+	struct {
+		struct nlmsghdr n;
+		struct ifinfomsg i;
+		char buf[XMIT_MAX_LEN];
+	} req;
+	struct ifinfomsg *ifi = (struct ifinfomsg *)(n + 1);
+	struct rtattr *tb[IFLA_MAX + 1];
+	struct rtattr *linkinfo[IFLA_INFO_MAX+1];
+	struct rtattr *vxlan_trunkinfo[IFLA_VXLAN_TRUNK_MAX + 1];
+	struct nlmsghdr *answer;
+	unsigned link = 0;
+	int len;
+
+	if (!(n->nlmsg_flags & NLM_F_CREATE)) {
+		memset(&req, 0, sizeof(req));
+
+		req.n.nlmsg_len = NLMSG_LENGTH(sizeof(*ifi));
+		req.n.nlmsg_flags = NLM_F_REQUEST;
+		req.n.nlmsg_type = RTM_GETLINK;
+		req.i.ifi_family = preferred_family;
+		req.i.ifi_index = ifi->ifi_index;
+
+		if (rtnl_talk(&rth, &req.n, &answer) < 0) {
+get_failed:
+			fprintf(stderr,
+				"Failed to get existing tunnel info.\n");
+			free(answer);
+			return -1;
+		}
+
+		len = answer->nlmsg_len;
+		len -= NLMSG_LENGTH(sizeof(*ifi));
+		if (len < 0)
+			goto get_failed;
+
+		parse_rtattr(tb, IFLA_MAX, IFLA_RTA(NLMSG_DATA(answer)), len);
+
+		if (!tb[IFLA_LINKINFO])
+			goto get_failed;
+
+		parse_rtattr_nested(linkinfo, IFLA_INFO_MAX, tb[IFLA_LINKINFO]);
+
+		if (!linkinfo[IFLA_INFO_DATA])
+			goto get_failed;
+
+		parse_rtattr_nested(vxlan_trunkinfo, IFLA_VXLAN_TRUNK_MAX,
+				    linkinfo[IFLA_INFO_DATA]);
+
+		if (vxlan_trunkinfo[IFLA_VXLAN_TRUNK_LINK])
+			link = rta_getattr_u32(vxlan_trunkinfo[IFLA_VXLAN_TRUNK_LINK]);
+
+		free(answer);
+	}
+
+	while (argc > 0) {
+		if (!matches(*argv, "link")) {
+			NEXT_ARG();
+			link = if_nametoindex(*argv);
+			if (link == 0) {
+				fprintf(stderr, "Cannot find device \"%s\"\n",
+					*argv);
+				exit(-1);
+			}
+		} else
+			usage();
+		argc--; argv++;
+	}
+
+	if (link)
+		addattr32(n, 1024, IFLA_VXLAN_TRUNK_LINK, link);
+
+	return 0;
+}
+
+static void vxlan_trunk_print_opt(struct link_util *lu, FILE *f, struct rtattr *tb[])
+{
+	char s2[64];
+
+	if (!tb)
+		return;
+
+	if (tb[IFLA_VXLAN_TRUNK_LINK] && rta_getattr_u32(tb[IFLA_VXLAN_TRUNK_LINK])) {
+		unsigned link = rta_getattr_u32(tb[IFLA_VXLAN_TRUNK_LINK]);
+		const char *n = if_indextoname(link, s2);
+
+		if (n)
+			fprintf(f, "link %s ", n);
+		else
+			fprintf(f, "link %u ", link);
+	}
+}
+
+static void vxlan_trunk_print_help(struct link_util *lu, int argc, char **argv,
+	FILE *f)
+{
+	print_usage(f);
+}
+
+struct link_util vxlantrunk_link_util = {
+	.id = "vxlantrunk",
+	.maxattr = IFLA_VXLAN_TRUNK_MAX,
+	.parse_opt  = vxlan_trunk_parse_opt,
+	.print_opt  = vxlan_trunk_print_opt,
+	.print_help = vxlan_trunk_print_help,
+};
+
+struct link_util vlantrunk_link_util = {
+	.id = "vlantrunk",
+	.maxattr = IFLA_VXLAN_TRUNK_MAX,
+	.parse_opt  = vxlan_trunk_parse_opt,
+	.print_opt  = vxlan_trunk_print_opt,
+	.print_help = vxlan_trunk_print_help,
+};
-- 
2.19.0

