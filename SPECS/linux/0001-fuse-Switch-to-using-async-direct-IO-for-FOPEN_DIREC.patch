From: Martin Raiber <martin@urbackup.org>
Date: Sat, 27 Oct 2018 16:48:48 +0000
Subject: [PATCH] fuse: Switch to using async direct IO for FOPEN_DIRECT_IO

commit 23c94e1cdcbf5953cd380555d0781caa42311870 upstream

Switch to using the async directo IO code path in fuse_direct_read_iter()
and fuse_direct_write_iter().  This is especially important in connection
with loop devices with direct IO enabled as loop assumes async direct io is
actually async.

Signed-off-by: Martin Raiber <martin@urbackup.org>
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
[Ashwin: Regenerated the patch for v4.4]
Signed-off-by: Ashwin Dayanand Kamat <kashwindayan@vmware.com>
---
 fs/fuse/file.c | 30 ++++++++++++++++++++++++++----
 1 file changed, 26 insertions(+), 4 deletions(-)

diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index f7d025d1684c..1f448cfecbcf 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -1437,10 +1437,25 @@ static ssize_t __fuse_direct_read(struct fuse_io_priv *io,
 	return res;
 }
 
+static ssize_t fuse_direct_IO(struct kiocb *iocb, struct iov_iter *iter, loff_t offset);
+
 static ssize_t fuse_direct_read_iter(struct kiocb *iocb, struct iov_iter *to)
 {
-	struct fuse_io_priv io = FUSE_IO_PRIV_SYNC(iocb->ki_filp);
-	return __fuse_direct_read(&io, to, &iocb->ki_pos);
+	ssize_t res;
+
+	if (!is_sync_kiocb(iocb) && iocb->ki_flags & IOCB_DIRECT) {
+		struct file *file = iocb->ki_filp;
+
+		if (is_bad_inode(file_inode(file)))
+			return -EIO;
+
+		res = fuse_direct_IO(iocb, to, iocb->ki_pos);
+	} else {
+		struct fuse_io_priv io = FUSE_IO_PRIV_SYNC(iocb->ki_filp);
+
+		res = __fuse_direct_read(&io, to, &iocb->ki_pos);
+	}
+	return res;
 }
 
 static ssize_t fuse_direct_write_iter(struct kiocb *iocb, struct iov_iter *from)
@@ -1456,8 +1471,14 @@ static ssize_t fuse_direct_write_iter(struct kiocb *iocb, struct iov_iter *from)
 	/* Don't allow parallel writes to the same file */
 	mutex_lock(&inode->i_mutex);
 	res = generic_write_checks(iocb, from);
-	if (res > 0)
-		res = fuse_direct_io(&io, from, &iocb->ki_pos, FUSE_DIO_WRITE);
+	if (res > 0) {
+		if (!is_sync_kiocb(iocb) && iocb->ki_flags & IOCB_DIRECT) {
+			res = fuse_direct_IO(iocb, from, iocb->ki_pos);
+		} else {
+			res = fuse_direct_io(&io, from, &iocb->ki_pos,
+					     FUSE_DIO_WRITE);
+		}
+	}
 	fuse_invalidate_attr(inode);
 	if (res > 0)
 		fuse_write_update_size(inode, iocb->ki_pos);
